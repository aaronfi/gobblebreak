<style>
    .move { margin: 1px; }
    .move:hover { background-color:yellow; }
    .possible_move { margin: 1px; display:inline-block; }
    .possible_move:hover { background-color:yellow; }
    .movenumber { color: lightslategray; }
    .variation { margin: 1rem 0 1rem 1rem; padding:0.25rem; }
    /* TODO(Aaron) styling to not have top-level variations broken out... reinstate?  */
    /* #moves > .variation { margin-left: 0; padding-left: 0; } */
    #moves { margin: 1rem; }
    .highlight:hover { border-left: 1px solid #add8e6; }
    .selected {  border: 1px solid #add8e6;}
    #resizable {
        padding: 0.5rem;
        width:65%;  /* TODO(aaron,4/12) programmatically set this initial width from user's preferences;  cookie? */
        margin-left:auto;
        margin-right:auto;
        margin-bottom: 200px;
    }
    .column2 {
        display: inline-block;
        vertical-align: top;
        overflow: auto;
        white-space:normal;
        border-radius: 6px;
    }
</style>

<script>
  $('.move').click( function() {
      // TODO:
      // $(this).my_custom_id;
      // game.call_some_method(my_custom_id)
  });

  var repeating = false;
  var repeatRateTimer = null;

  // TODO(aaron,4/3) experiment with different throttle step up rates here
  // TODO(aaron,4/3) add a "1 move / sec", "4 moves /sec" display text while throttling;
  // TODO(aaron,4/3) add user config for max_moves_per_sec_when_holding_down_arrow_key  ?
  var throttle_steps = [
                        150, 150,
                        125, 125,
                        100,
                        25];
  var throttle_count = -1;
  // TODO(aaron,4/5) past some lower threshold, just have prev() call board(fen, false) instead of board(fen);  updates immediately without animation delay

  // TODO(aaron,4/20/14) when you finally build a puzzle editor, give the user the ability to let the computer try and solve the puzzle;  also, let the computer just analyze the puzzle and return the next best move

  $(document).keyup( function(e) {
      if (repeatRateTimer != null) {
          clearTimeout(repeatRateTimer);
          repeatRateTimer = null;
      }

      repeating = false;
      cfg.moveSpeed = 150;
      throttle_count = -1;
  });

  $(document).keydown( function(e) {
      if (repeating == true) {
          throttle_count = Math.min(throttle_steps.length-1, throttle_count + 1);

          cfg.moveSpeed = throttle_steps[throttle_count];
          if (repeatRateTimer == null) {
              repeatRateTimer = setTimeout(function() {
                  repeating = false;
                  clearTimeout(repeatRateTimer);
                  repeatRateTimer = null;
              }, 25);
          }

          return;
      }
      repeating = true;  // TODO(aaron,5/8/14) see if i can replace this with $(document).keypress( function(e) { .....     http://www.moreonfew.com/how-to-identify-keycode-or-key-pressed-in-jquery/

      // keyboard logic
      if (board.is_animating()) {
          return;
      }

      var tag = e.target.tagName.toLowerCase();
      if (tag != 'input' && tag != 'textarea') {
          switch(e.which) {
              case 37:  // left arrow
                  prev();
                  e.preventDefault();
                  break;
              case 38:  // up arrow
                  up();
                  e.preventDefault();
                  break;
              case 39:  // right arrow
                  next();
                  e.preventDefault();
                  break;
              case 40:  // down arrow
                  down();
                  e.preventDefault();
                  break;
              case 13:  // enter key
                  break;
          }
      }
  });
</script>

<% # TODO(aaron,4/3) cool idea -- rig up javascript that just lets you type moves immediately, without prompt.  %>

<div class="container" id="topContainer">
    <div class="row" id="moveList">
        <div class="col-sm-2"></div>
        <div class="col-sm-7">
            <div class="container">
                <textarea id="debug2"></textarea>
            </div>
        </div>
        <div class="col-sm-3"></div>
    </div>

    <div class="row">
        <div class="col-sm-2" id="leftPane">

            <div class="container">
                <div class="row">
                    <div class="col-sm-12"><div id="button1" class="btn btn-secondary" onclick="toggleComputer()" value="on">Computer: On</div></div>
                </div>
            </div>
            <div class="row">
                <div class="col-sm-12"><div class="column2" id="games"></div></div>
                <div class="col-sm-12"><div class="column2" id="possible_moves"></div></div>
            </div>
        </div>

        <div class="col-sm-7">
            <div class="ui-content-widget ui-resizable" id="resizable">
                <div id="board" class="animate tossing"></div>
            </div>
        </div>

        <div class="col-sm-3" id="rightPane">
            <div id="moves" />
            <textarea id="debug1"></textarea>
            <textarea id="debug3"></textarea>
        </div>
    </div>
</div>

<script>
    computer = true;  // TODO(aaron,5/1/14) hacky, replace with config?
    function toggleComputer() {
        if ($('#button1').attr('value') == "off") {
            $('#button1').text("Computer: On");
            $('#button1').attr('value', 'on');
            computer = true;
        } else {
            $('#button1').text("Computer: Off");
            $('#button1').attr('value', 'off');
            computer = false;
        }
    }

    function print_debug() {  // eventually remove this function and all its uses
        var does_board_match_display = board.fen() === game.fen().split(' ')[0];
        $('#debug1').text(' ' + game.ascii() + '\nBoard matches display? ' +  (does_board_match_display ? 'Yes' : '**NO**'));
        $('#debug2').text(game.pgn({ show_selected_move: true }));
        $('#debug3').text(game.log().join('\n'));
    }

    function displayPossibleMoves() {
        $('#possible_moves').empty();
        var moves = game.moves();
        for(var i=0; i < moves.length; i++) {
            $("<span/>", { class: 'possible_move', text: moves[i] }).appendTo($('#possible_moves'));
        }
    }

    function make_computer_move() {
        setTimeout(function() {
            var found_move  = engine.find_best_move(game.fen());

            var move_obj = { from: game.convert_extended_square_to_algebraic(found_move[0]), to: game.convert_extended_square_to_algebraic(found_move[1]), promotion: 'q'};
            var result_move = game.move(move_obj);
            addMove(result_move.san);
            board.move(game.convert_extended_square_to_algebraic(found_move[0]) + "-" + game.convert_extended_square_to_algebraic(found_move[1]));
            board.position(game.fen());
            print_debug();

            displayPossibleMoves();
        }, 750);
    }

    var variation_mouseover = function(e) {
        e.stopPropagation();
        $('.highlight').removeClass('highlight');
        $(this).addClass('highlight');
    };
    var variation_mouseout =  function(e) {
        e.stopPropagation();
        $(this).removeClass('highlight');
    };
    $('.variation').mouseover(variation_mouseover);
    $('.variation').mouseout(variation_mouseout);

    var moveID = 0;

    function addMove(move) {
        var selected = $('.selected');
        var parent = selected.parent();
        var root = parent;

        var next = selected.attr('data-next');
        var prev = selected.attr('data-prev');
        var continuations = selected.attr('data-continuations');

        selected.removeClass('selected');

        if (next) {
            if ($('#' + next).text() === move) {
                $('#' + next).addClass('selected');
                return;
            }
        }

        if (continuations) {
            var conts = continuations.split(',');
            for(var i=0; i<conts.length; i++) {
                if ($('#' + conts[i]).text() === move) {
                    $('#' + conts[i]).addClass('selected');
                    return;
                }
            }
        }

        // if we made it this far, then we're adding a new move

        var nodeID = 'move' + (++moveID);
        var node = $("<span/>", { class: 'move selected', text: move, id: nodeID });

        if (next) {
            node.attr('data-prev', selected.attr('id'));
            selected.attr('data-continuations', (continuations ? continuations + ',' : '') + nodeID);

            var anchor = parent.is(':last-child') ? parent : parent.next('.movegroup');
            var white_moved_last = selected.next('.move').length > 0;

            $("<div/>", { class: 'variation'}).append(
                $("<div/>", { class: 'movegroup' })
                    .append(' ')
                    .append(anchor.children('.movenumber:first').clone())
                    .append(' ')
                    .append( white_moved_last ? $("<span/>", { class: 'ellipsis', text: "..." }) : '')
                    .append( white_moved_last ? ' ' : '')
                    .append(node)
            ).mouseover(variation_mouseover).mouseout(variation_mouseout)
            .insertAfter(anchor);
        } else if (parent.next('.movegroup').length > 0) {
            node.attr('data-prev', selected.attr('id'));
            $('#' + selected.attr('data-prev')).attr('data-continuations', (continuations ? continuations + ',' : '') + nodeID);

            var anchor = parent.is(':last-child') ? parent : parent.next('.movegroup');

            $("<div/>", { class: 'variation'}).append(
                $("<div/>", { class: 'movegroup' })
                    .append(' ')
                    .append(
                    $("<span/>", {
                        class: 'movenumber',
                        text:  parseInt(anchor.children('.movenumber:first').text().slice(0, -1), 10) + 1 + '.'
                    }))
                    .append(' ')
                    .append(node)
            ).mouseover(variation_mouseover).mouseout(variation_mouseout)
            .insertAfter(anchor);
        } else {

            node.attr('data-prev', selected.attr('id'));
            selected.attr('data-next', nodeID);

            if (selected.index() == 1) {
                root.append(' ').append(node);
            } else if ($('#moves').children().length == 1) {  // first move ever...
                $("<div/>", { class: 'movegroup' })
                    .append(' ')
                    .append(
                    $("<span/>", {
                        class: 'movenumber',
                        text:  '1.'              // TODO(aaron,4/6) assumes first move is always white, which isn't necessarily correct
                    }))
                    .append(' ')
                    .append(node)
                    .appendTo($('#moves'));
            } else {
                var anchor = parent.is(':last-child') ? parent : parent.nextAll('.variation').last();

                $("<div/>", { class: 'movegroup' })
                    .append(' ')
                    .append(
                    $("<span/>", {
                        class: 'movenumber',
                        text:  parseInt(parent.children(':first-child').text().slice(0, -1), 10) + 1 + '.'
                    }))
                    .append(' ')
                    .append(node)
                    .insertAfter(anchor);
            }
        }
    }

    function prev() {
        game.prev();
        board.position(game.fen());

        // reassign "#selected" node
        var selected = $('.selected');
        var prev = selected.attr('data-prev');

        if (prev) {
           selected.removeClass('selected');
           $('#' + prev).addClass('selected');
        }
        print_debug();
        displayPossibleMoves();
    }

    function next() {
        game.next();
        board.position(game.fen());

        // reassign "#selected" node
        var selected = $('.selected');
        var next = selected.attr('data-next');

        if (next) {
            selected.removeClass('selected');
            $('#' + next).addClass('selected');
        }
        print_debug();
        displayPossibleMoves();
    }

    // TODO(aaron) need to prompt for which variation, then pass it along to this function;  there could be more than one;  defaults to first, for now
    function down(i) {
        if (typeof i === 'undefined') {
            i=0;
        }

        if (game.descend_into_continuation(i)) {
            board.position(game.fen());

            // reassign "#selected" node
            var selected = $('.selected');

            var conts = selected.attr('data-continuations').split(',');
            var next = conts[i];

            if (next) {
                selected.removeClass('selected');
                $('#' + next).addClass('selected');
            }
            print_debug();
            displayPossibleMoves();
        }
    }

    function up() {
        if (game.ascend_from_current_continuation()) {
            board.position(game.fen());

            // reassign "#selected" node
            var selected = $('.selected');
            var prev = selected.attr('data-prev');

            if (prev) {
                selected.removeClass('selected');
                $('#' + prev).addClass('selected');
            }
            print_debug();
            displayPossibleMoves();
        }
    }

    var starting_turn = 'w',
        board,
        game = new Chess(),
        engine = new Engine(),
        games = [
            ['[FEN "rnbqkbnr/pppp1ppp/8/8/4p3/4PN2/PPPP1PPP/RNBQKB1R w KQkq - 0 3"]'],
            ['[Event "1001 Brilliant Mates"]',
                '[Site "No forced mate in this position???"]',
                '[Date "????.??.??"]',
                '[Round "?"]',
                '[White "BWTC.0005"]',
                '[Result "*"]',
                '[SetUp "1"]',
                '[FEN "r2qk1r1/p4p2/bp2pQp1/1n1pP1Bp/7P/3P2N1/P1R2PP1/2R3K1 w q - 0 1"]',
                '[PlyCount "8"]',
                '',
                '1. Rc8 Rxc8 2. Rxc8 Kd7 3. Rxd8+ Rxd8 4. Qxd8+ Kc6'],
            ['1. d4 (1. c4 (1. b4 (1. a4 a5) 1... b5) 1... c5) (1. e4 (1. f4 (1. g4 (1. h4 h5) 1... g5) 1... f5) 1... e5) 1... d5 (1... c5 (1... b5 (1... a5))) (1... e5 (1... f5 (1... g5 2. g3) 2. f3) 2. e3) e3 (f3 f6) (g3 g6) (h3 h6) e6 *'],
            ['1. e4 e5 2. f4 exf4 3. Nf3 g5 4. h4 g4 5. Ne5 Nf6 6. Nxg4 Nxe4 7. d3 Ng3 8. Bxf4 Nxh1 9. Qe2+ Qe7 10. Nf6+ Kd8 11. Bxc7+ Kxc7 12. Nd5+ Kd8 13. Nxe7 Bxe7 14. Qg4 d6 15. Qf4 Rg8 16. Qxf7 Bxh4+ 17. Kd2 Re8 18. Na3 Na6 19. Qh5 Bf6 20. Qxh1 Bxb2 21. Qh4+ Kd7 22. Rb1 Bxa3 23. Qa4+'],
            ['[Event "1001 Brilliant Mates"]',
             '[White "BWTC.0004"]',
             '[Result "*"]',
             '[FEN "r1b1k2r/pp2bppp/8/3N2q1/2p5/8/PPP2PPP/R2QR1K1 w kq - 0 1"]',
             '',
             '1. Nc7+']
        ];

    for(var i=0; i<games.length; i++) {
        $("<div/>", { class: 'game' })
            .append("Game " + (i+1))
            .click(function() {
                game.reset();
                loadGame($(this).index());
             })
            .mouseover(variation_mouseover)
            .mouseout(variation_mouseout)
            .appendTo($('#games'));
    }

    function loadGame(i) {
        game.load_pgn(games[i].join('\n'), { is_puzzle_solution: true });
        print_debug();
        displayPossibleMoves();
        board.position(game.fen());
        starting_turn = game.turn();
    }

    // TODO(aaron,4/7) add a "Suggest next move" button...


    /* TODO(aaron4/7) there currently exists some extra logging noise in the replay_log;

     "[Event "1001 Brilliant Mates"]
     [White "BWTC.0004"]
     [Result "*"]
     [FEN "r1b1k2r/pp2bppp/8/3N2q1/2p5/8/PPP2PPP/R2QR1K1 w kq - 0 1"]

     1. Nc7+ (1. Ne3) *"


     ---->  ["1969: prev()", "13975: create_variation('Ne3',false)", "16126: prev()", "16126: ascend_from_current_variation()", "17882: move('Nc7+')"]
    */

    var removeGreySquares = function() {
        $('#board .square-55d63').css('background', '');
    };

    var greySquare = function(square) {
        var squareEl = $('#board .square-' + square);

        var background = '#a9a9a9';
        if (squareEl.hasClass('black-3c85d') === true) {
            background = '#696969';
        }

        squareEl.css('background', background);
    };

    var onDragStart = function(source, piece) {
        // do not pick up pieces if the chess game is over or if it's not that side's turn
        if (game.is_game_over() === true ||
                (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
            return false;
        }
    };

    var onDrop = function(source, target) {
        removeGreySquares();  // remove highlights

        // see if the move is legal
        // TODO(aaron,4/13) wire up to a user option
        if (jQuery.inArray(target, game.moves({output_only_algebraic_squares: true, square: source})) == -1) {
            return 'snapback';
        }

        // NOTE: always promote to a pawn for example simplicity
        // TODO(aaron,3/25) need a modal prompt of some kind to choose the promotion piece
        var move = game.move({
            from: source,
            to: target,
            promotion: 'q'
        });

        // illegal move
        if (!move) return 'snapback';

        addMove(move.san);

        print_debug();

        displayPossibleMoves();

        // TODO(aaron,4/7) need to add a "guard";  currently the user can just right-arrow advance through the
        // entire puzzle solution.  Need to deny them this ability.

        // process and apply the opponent's move in response, if any
        if (computer && game.turn() !== starting_turn) {
            if (move.is_puzzle_solution) {
                console.log("closer...");  // TODO(Aaron) remove debuggery

                var next_move = game.next();
                if (next_move) {
                    // NOTE(aaron,4.7.14) need to wrap this in a delay timer, otherwise the move animation sequence will misbehave
                    setTimeout(function() {
                        addMove(next_move.move.move_text);
                        board.move(game.convert_move_to_algebraic(next_move));
                        board.position(game.fen());

                        if (! game.next()) {
                            console.log("puzzle was finished! -- no more White moves needed")
                        } else {
                            game.prev();  // restore our state prior to our inspection fo the next move
                        }

                        print_debug();
                    }, 750);
                } else {
                    console.log("puzzle was finished - black has no further recorded moves!!");
                    is_puzzle_solved = true;
                    make_computer_move();
                }
            } else {
                make_computer_move();
            }
        }

        // NOTE(aaron,5/1/14) this mostly fixes a UI bug where the Rook's movement in castling
        // would not get animated until the other player's next turn.  Ideally, the rook's movement
        // would be animated, but trying board.position(game.fen(), true) just results in broken UI.
        // Leaving unaminated, for now.
        if (move.san.substring(0,3) == 'O-O') {
            board.position(game.fen(), false);
        }
        // /NOTE
    };

    // TODO(aaron,4/5/14) idea:  let people share their attempted solution to a puzzle;  nice url for this?  preloaded PGN-attempt vs PGN-solution

    var onDragMove = function(location, prev_location, origin_location, piece, current_position, current_orientation) {
        // limit square highlighting to only legal moves;
        // TODO(aaron,4/13) wire up to a user option

        if (jQuery.inArray(location, game.moves({output_only_algebraic_squares: true, square: origin_location})) == -1) {
            // TODO(aaron,4/7) super hacky... exposing internal constants within chessboardjs like this.
            $('#' + board.SQUARE_ELS_IDS()[location]).removeClass(board.CSS().highlight2);
        }
    };

    var onMouseoverSquare = function(square, piece) {
        // get list of possible moves for this square
        var moves = game.moves({
            square: square,
            verbose: true
        });

        // exit if there are no moves available for this square
        if (moves.length === 0) return;

        // TODO(4/3/14) whatever happened to UI support for square-select (origin), then square-select (destination)?
        // make this one of the UI preferences?

        var squareEl = $('#board .square-' + square);
        squareEl.addClass('highlight2-9c5d2');

        // highlight the possible squares for this piece
        for (var i = 0; i < moves.length; i++) {
            greySquare(moves[i].to);
        }
    };

    var onMouseoutSquare = function(square, piece) {
        var squareEl = $('#board .square-' + square);
        squareEl.removeClass('highlight2-9c5d2');
        removeGreySquares();  // remove highlights
    };

    var cfg = {
        draggable: true,
        position: 'start',
        onDragStart: onDragStart,
        onDragMove: onDragMove,
        onDrop: onDrop,
        onMouseoutSquare: onMouseoutSquare,
        onMouseoverSquare: onMouseoverSquare,
        showNotation: false,  // TODO(aaron,4/2) move to user configuration;  also, currently shows board letters inside board;  can we move it outside as well?
        pieceTheme: '/assets/images/chesspieces/wikipedia/{piece}.png',  // TODO(aaron,4/2) let user jigger with piece icons... save as user configuration
        position: game.fen(),
        moveSpeed: 200,
        showErrors: 'console'
    };
    board = new ChessBoard('board', cfg);

    // TODO(aaron,4/13) another idea:  extend your PGN model to allow for general-purpose annotation of from whom a particular movetree fragment originated
    // e.g. "a specific user", "original puzzle solution", "auto-calculated by computer solver" --> does this mean I could eventually have some kind of
    // Darwin (amazon's system) like system where the community of users at large, or some automatic puzzle solver, could detect new move fragments to add
    // to an existing puzzle -- perhaps even "promote" those fragments into the puzzle's official cannon?  (that vs. copy/fork into a new puzzle?)

    $('#resizable').resizable({
        resize: function(event, ui) {
            $('#board > div > div').css({ 'border-color': 'blue' });

            $("#board").width( ui.size.width );
            $("#board").height( ui.size.width );  // not a typo;  we set board's height equal to UI's width, to enforce a square board
            board.resize();

            // for some reason, these two commands are necessary;  otherwise the resize triangle can end up misaligned.
            $('#resizable').width( $('#board').width() );
            $('#resizable').height( $('#board').width() );
        },
        stop: function(event, ui) {
            $('#board > div > div').css({ 'border-color': 'black' });
        },
        aspectRatio: true,
        grid: [8,8],
        handles: "nw, se"
    });

    $('#resizable .ui-icon-gripsmall-diagonal-se')
        .addClass('ui-icon-grip-diagonal-se')  // slight stylistic change, adding a better "click-drag" icon
        .removeClass('ui-icon-gripsmall-diagonal-se')
        .hover(
            function() {
                $('#board > div > div').css({ 'border-color': 'blue' });
            },
            function() {
                $('#board > div > div').css({ 'border-color': 'black' });
            })
        .mousedown(function() {
                $('#board > div > div').css({ 'border-color': 'blue' });
            })
        .mouseup(function() {
                $('#board > div > div').css({ 'border-color': 'black' });
            });

    print_debug();
    displayPossibleMoves();

    loadGame(0);
</script>

<script>

    $(window).load(function () {
        var e, t, n, i, r, o, s;
        r = $("#subheading");
        if (r.length > 0) {
            e = $('<span class="jqconsole-cursor user-color user_0"></span>');
            t = $('<span class="jqconsole-cursor user-color user_1"></span>');
            o = function (e, t, n) {
                var i;
                if (0 !== t.length) {
                    e.text(e.text() + t.charAt(0));
                    i = 40 + 40 * Math.random();  // x == min delay in ms;  y == random number weighting offset
                    return setTimeout(function () {
                                return o(e, t.slice(1), n);
                            }
                            , i);
                }
                n && n();
            };
            s = function (e, t, n) {
                if (0 !== t.length)
                    return o(e, t[0], function () {
                                var i;
                                i = $('<span class="text"/>').insertAfter(e);
                                return s(i, t.slice(1), n);
                            }
                    );
                n && n();
                return void 0;
            };
            n = $('<span class="text"/>');
            i = ["The world's first", " platform for chess puzzles."];
            r.empty().append(n).append(e);
            return s(n, i, function () {
                        return setTimeout(function () {
                                    var n;
                                    n = r.children().first();
                                    e.fadeOut();
                                    t.insertAfter(n);
                                    return setTimeout(function () {
                                                return o(n, " open", function () {
                                                            // debugger;
                                                            return setTimeout(function () {
                                                                        t.detach();
                                                                        return setTimeout(function () {
                                                                                    return $(".jqconsole-cursor").fadeOut();
                                                                                }
                                                                                , 300);
                                                                    }
                                                                    , 100);
                                                        }
                                                )
                                            }
                                            , 100);
                                }
                                , 400);
                    }
            );
        }
    });
</script>